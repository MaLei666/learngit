# -*- coding:utf-8 -*-
# @author : MaLei 
# @datetime : 2020/12/15 10:59
# @file : Multiple inheritance.py
# @software : PyCharm


'''
任何实现多重继承的语言都要处理潜在的命名冲突
这种冲突由不相关 的祖先类实现同名方法引起
这种冲突称为“菱形问题”
'''

# class Table:
#     def A(self):
#         print('A')
#
#
# class Table2(Table):
#     def B(self):
#         print('B')
#
#
# class Table3(Table):
#     def B(self):
#         print('b')
#
#
# # 方法解析顺序不仅考虑继承图，还考虑子类声明中列出超类的顺序。
# class Table4(Table2, Table3):
#     # class Table4(Table3, Table2):
#     def A(self):
#         super().A()
#
#     # 若想把方法调用委托给超类，推荐的方式是使用内置的 super()
#     def C(self):
#         self.B()
#         super().B()
#         self.A()
#         super().A()
#         # 有时可能需要绕过方法解析顺序，直接 调用某个超类的方法
#         Table3().B()
#
#
# # 直接调用 运行的是 Table2 类中的版本
# t = Table4()
# t.A()
# t.B()
# print('*' * 100)
# t.C()
#
# # 超类中的方法都可以直接调用，此时要把实例作为显式参数传入
# print('*' * 100)
# t2 = Table3()
# t2.B()
# Table3.B(t)
#
# # Python 能区分 d.pong() 调用的是哪个方法，是因为 Python 会按照特定 的顺序遍历继承图。
# # 这个顺序叫方法解析顺序（Method Resolution Order，MRO）。
# # 类都有一个名为 __mro__ 的属性，它的值是一个元 组，按照方法解析顺序列出各个超类，
# # 从当前类一直向上，直到 object 类。
# print(Table4.__mro__)


# 01. 把接口继承和实现继承区分开使用多重继承时，一定要明确一开始为什么创建子类。
# 主要原因可能有：
# 继承接口，创建子类型，实现“是什么”关系
# 继承实现，通过重用避免代码重复
# 其实这两条经常同时出现，不过只要可能，一定要明确意图。
# 通过继承重用代码是实现细节，通常可以换用组合和委托模式。而接口继承则是框架的支柱。

# 02.使用抽象基类显式表示接口
# 现代的Python中，如果类的作用是定义接口，应该明确把它定义为抽象基类。
# Python3.4及以上的版本中，我们要创建abc.ABC或其他抽象基类的子类

# 03.通过混入重用代码
# 如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现“是什么”关系
# 应该把那个类明确地定义为混入类（mixinclass）。
# 从概念上讲，混入不定义新类型，只是打包方法，便于重用。
# 混入类绝对不能实例化，而且具体类不能只继承混入类。
# 混入类应该提供某方面的特定行为，只实现少量关系非常紧密的方法

# 04.在名称中明确指明混入
# 因为在Python中没有把类声明为混入的正规方式，所以强烈推荐在名称中加入...Mixin后缀。

# 05.抽象基类可以作为混入，反过来则不成立
# 抽象基类可以实现具体方法，因此也可以作为混入使用。
# 不过，抽象基类会定义类型，而混入做不到。
# 此外，抽象基类可以作为其他类的唯一基类，而混入决不能作为唯一的超类，除非继承另一个更具体的混入——真实的代码很少这样做。
# 抽象基类有个局限是混入没有的：
# 抽象基类中实现的具体方法只能与抽象基类及其超类中的方法协作。
# 这表明，抽象基类中的具体方法只是一种便利措施，因为这些方法所做的一切，用户调用抽象基类中的其他方法也能做到

# 06.不要子类化多个具体类具体类可以没有，或最多只有一个具体超类。
# 也就是说，具体类的超类中除了这一个具体超类之外，其余的都是抽象基类或混入

# 07. 为用户提供聚合类
# 如果抽象基类或混入的组合对客户代码非常有用，那就提供一个类，使用易于理解的方式把它们结合起来。
# Grady Booch把这种类称为聚合类（aggregate class）。

# 08. “优先使用对象组合，而不是类继承”
# 这 是我能提供的最佳建议。熟悉继承之后，就太容易过度使用它了。
# 然而，优先使用组合能让设计更灵活。
# 子类化是一种紧耦合，而且较高的继承树容易倒。
# 组合和委托可以代替混入，把行为提供给不同的类，但是不能取代接口继承去定义类型层次结构。
